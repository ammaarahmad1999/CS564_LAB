# -*- coding: utf-8 -*-
"""K_Medoid.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-GzRXWwq3CtU7mxLXQz0uca8JbzgYVlb
"""

import pandas as pd
import numpy as np

import math

# Commented out IPython magic to ensure Python compatibility.
# %cp /content/drive/MyDrive/BR_mod.csv ./

df = pd.read_csv("BR_mod.csv")

df

df.columns

df.median()

for column in df.columns:
    df[column].fillna(df[column].median(), inplace=True)

df

data = df.to_numpy()

type(data)

length = data.shape[0]
print(length)

k_values = np.arange(2, 11, 1)
print(k_values)
cost_values = []

def cost_cal(centroid, Z):                  # Calculating the euclidian distance to find cost for particular cluster
  cost = 0
  for i, x in enumerate(data):
    j = int (Z[i])
    y = centroid[j]
    cost += np.linalg.norm(y - x)
  return cost

def cluster(centroid, K):                   # Function to find the cluster with given K centroid
  Y = np.zeros(length)
  for i, x in enumerate(data):
      dist = np.zeros(K)
      for j, y in enumerate(centroid):
        dist[j] = np.linalg.norm(y - x)
      Y[i] = np.argmin(dist)
  return Y

def K_mediod_clustering(K = 2):
  
  centroid = (df.sample(n=K)).to_numpy()    # Randomly select K centroid
  Y = cluster(centroid, K)  
  cost = cost_cal(centroid, Y)
  iter = 0
  while (1):                                # Run to find minimum cost
    change = False
    for i, x in enumerate(data):            # Changing medoid to one of non-medoid data points
      new_centroid = centroid             
      if x.tolist() in centroid.tolist():   # If data point is already a medoid
        continue
      z = int(Y[i])                         
      new_centroid[z] = x
      Z = cluster(new_centroid, K)          # Finding clusters with new medoid
      new_cost = cost_cal(new_centroid, Z)  # New Cost
      iter += 1
      if(iter%1000==0):
        print(iter)
      if (new_cost < cost):                 # If new cost is less than original cost
        cost = new_cost
        Y = Z
        centroid = new_centroid             # New Centroid
        change = True
        break
    if change == False:                     # If no change in last iteration of data point then minimum cost is found
      break
  #print(iter)                              # Printing No. of iterations taken to find minimum cost
  
  cost_values.append(cost)
  return Y, cost, centroid

for k in k_values:
  K_mediod_clustering(k)

import matplotlib.pyplot as plt
plt.plot(k_values, cost_values, 'bx-')
plt.xlabel('Values of K')
plt.ylabel('Cost')
plt.title('The Elbow Method using Cost')
plt.show()

Y, cost, centroid = K_mediod_clustering(7)
print(Y)
print(cost)
print(centroid)

def find(x):
  org = x
  while (clusters[x] != x):
    x = clusters[x]
  par = x
  x = org 
  while (clusters[x] != par):
    clusters[x] = par
    x = clusters[x]
  return par

clusters = [1, 1, 2, 4, 5, 6, 1, 8, 9, 10]

find(6)

print(centroid)

print(centroid)